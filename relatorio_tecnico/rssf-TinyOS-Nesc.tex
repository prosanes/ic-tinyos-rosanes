Uma rede de sensores sem fio (RSSF) é um conjunto de dispositivos formando uma rede de comunicação \textit{ad-hoc}. Cada
sensor tem a capacidade de monitorar diversas propriedades físicas, como intensidade luminosa, temperatura, aceleração,
entre outras. Através de troca de mensagens, esses dispositivos podem unir todas essas informações para detectar um evento
importante no local, como um incêndio. Essa conclusão é então encaminhada para um nó com maior capacidade computacional,
conhecido como estação base. Este nó pode decidir uma ação a ser tomada, ou enviar a informação pela internet. Uma RSSF
é usada para monitorar ambientes de difícil acesso, onde uma rede cabeada seria inviável ou custosa.
Alguns exemplos reais do uso de RRSF são: monitoramento da ponte Golden Gate em São Francisco, e dos vulcões Reventador e Tungurahua no
Equador~\cite{LevisGay/09}. 
Além da necessidade de serem sem fio, a outra principal característica dos sensores é o baixo consumo de energia. Para
evitar manutenções da rede, em ambientes de difícil acesso.

Para aumentar o tempo de vida das baterias, o hardware destes dispositivos tende a ter recursos computacionais
limitados. Ao invés de utilizar CPUs, são usados microcontroladores de 8 ou 16 bits, com frequências na ordem de 10
megahertz. Para armazenar o código da aplicação é utilizada uma pequena memória flash, da ordem de 100kB. E para as
variáveis existe uma memória RAM, da ordem de 10kB. Os circuitos de rádio também têm uma capacidade reduzida de
transferência, da ordem de kilobytes por segundos~\cite{LevisGay/09}.
Aliado ao hardware, o software também deve ser voltado para o baixo consumo de energia e de memória.

O TinyOS é o sistema operacional mais usado para auxiliar os programadores a desenvolverem aplicativos de baixo consumo. Junto com a
linguagem de programação nesC, é provido um modelo de programação baseado em componentes e orientado a eventos.
Os componentes são pedaços de código reutilizáveis, onde são definidas claramente suas dependências e os serviços
oferecidos, por meio de interfaces. É através da conexão (\textit{wiring}) de diversos componentes que o sistema é montado.

Já o modelo de programação orientado a eventos permite que o TinyOS rode uma aplicação, com somente uma linha de
execução, sem a necessidade de ações bloqueantes. Todas as operações de entrada e saída são realizadas em duas fases.
Na primeira fase, o comando de E/S sinaliza para o hardware o que deve ser feito, e retorna imediatamente, dando continuidade a
execução. A conclusão da operação é sinalizada através de um evento, que será tratado pela segunda fase da operação de E/S.

O modelo de programação baseada em compontenes está intimamente ligada à programação orientada a eventos: Um componente
oferece a interface, implementando os comandos e as sinalizações dos evento relacionandos, enquanto outro componente
utiliza a esta interface, utilizando os comandos e implementando os tratadores de evento.

Também é implementado o conceito de procedimento postergados, chamados de tarefas, ou \textit{tasks}, no TinyOS. Qualquer
componentes pode postar uma tarefa, que será atendida pelo escalonador, algum tempo depois, de forma síncrona.  Elas são 
executadas de forma não preemptiva entre si, o que ajuda a evitar condições de corrida. Além de serem utilizadas para
sairmos de um contexto assíncrono para um contexto síncrono. 
Por exemplo, um tratador de interrupção deve fazer somente o processamento mínimo, como transferência de dados entre o
\textit{buffer} e a memória. Após isto, deve postar uma tarefa para sinalizar o evento 
de conclusão da operação de E/S. Depois de um curto periodo de tempo, esta terefa será atendida, e sinalizará o evento de 
forma síncrona.

O TinyOS, assim como qualquer outro sistema operacional, também provê um conjunto de abstrações de hardware, como serviços 
de sensoreamento, comunicação e armazenamento.

A aplicação \textit{Blink}, no anexo~\ref{a:Blink}, é utilizada para ilustrar estes conceitos básicos. Nesta aplicação, são utilizados
3 temporizadores, que ligam/desligam os LEDs toda vez que são ativados. Dentre os conceitos explicados acima, temos:
\begin{itemize}
\item Definição das dependências através de interfaces --- uses interface Timer<TMilli> as Timer0;
\item Conexão entre componentes --- components new TimerMilliC() as Timer0; \hfill \\
        BlinkC.Timer0 -> Timer0;
\item Chamada a um comando --- call Time0.startPeriodic(250);
\item Tratador de evento --- event void Timer0.fired()
\item Definição de tarefas --- task void tarefa()
\item Postagem de tarefas --- post tarefa();
\end{itemize}
% ANEXAR
