\documentclass[a4paper, 10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese,brazil]{babel}
\usepackage{ae}
\usepackage{verbatim}

\usepackage[pdftex]{graphicx} % Exposta para pdf e aceita figuras
%\usepackage{indentfirst} % Identa primeiro paragrafo
\usepackage{textcomp}
\usepackage[margin=30mm]{geometry}
\usepackage[pdfauthor={Pedro Rosanes},% Insere metadados com o nome do autor
	    pdftitle={Extensão dos mecanismos de gerência de tarefas do sistema operacional TinyOS},% Título que será mostrado na janela do PDF
	    pdftex]{hyperref} % Usa hiperlinks no decorrer do texto
%\parskip 7.2pt           % sets spacing between paragraphs
\renewcommand{\baselinestretch}{1.5}


\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
%captionpos=b,                   % sets the caption-position to bottom
%breaklines=true,                % sets automatic line breaking
%breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title=\caption,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
escapeinside={\%*}{*)},         % if you want to add a comment within your code
morekeywords={module,uses,interface,implementation,
                task,event,call,post,configuration,
                components,as,async,command,error_t,
                atomic,uint8_t,uint16_t,uint32_t,
                int8_t,int16_t,int32_t,
                signal,generic,provides},            % if you want to add more keywords to the set
belowskip=0pt
}

%---------------------------------------------------------------------------------------------------
\title{Extensão dos mecanismos de gerência de tarefas do sistema operacional TinyOS}
\author{Bolsista: Pedro Rosanes \and Orientador: Silvana Rossetto \and Departamento de Ciência da Computação}
\date{11 de abril de 2011}

\begin{document}

\begin{titlepage}
\maketitle
\tableofcontents
\end{titlepage}

\abstract{Resumo}\label{resumo}
Redes de Sensores Sem Fio (RSSFs) são formadas por pequenos dispositivos de sensoreamento, com 
espaço de memória e capacidade de processamento limitados, fonte de energia esgotável e comunicação sem fio.
O sistema operacional mais usado na programação desses dispositivos é o TinyOS, um sistema leve, 
projetado especialmente para consumir pouca energia, um dos requisitos mais importante para RSSFs. 
%O modelo  programação adotado pelo TinyOS é orientada a componentes (para facilitar a
%reutilização de código) e basedo em eventos (para economizar memória), 
O modelo de programação adotado pelo TinyOS prioriza o atendimento de interrupções.
Em função disso, as operações são normalmente divididas em duas fases: uma para envio
do comando, e outra para o tratamento da resposta (evento sinalizado via interrupção). 
Esse modelo de programação, baseado em eventos, quebra o fluxo de execução normal, dificultando a
tarefa dos desenvolvedores de aplicações. 
Para que os tratadores de eventos (interrupções) sejam curtos, tarefas maiores são
postergadas para execução futura e, para evitar concorrência entre elas,
as tarefas são executadas em sequência, uma após a outra (i.e., uma tarefa só é iniciada após a tarefa
anterior ser concluída).  
O objetivo deste trabalho é propor e implementar políticas alternativas de escalonamento de tarefas
para o TinyOS visando a construção de abstrações de programação de nível mais alto que 
facilitem o desenvolvimento de aplicações nessa área.

%----------------------------------------------------------------------------------------------------
\section{Introdução}\label{intro}
Redes de Sensores Sem Fio (RSSFs) caracterizam-se pela formação de aglomerados de pequenos 
dispositivos que, atuando em conjunto, permitem monitorar ambientes físicos ou processos de 
produção com elevado grau de precisão. O desenvolvimento de aplicações que permitam explorar 
o uso dessas redes requer o estudo e a experimentação de protocolos, algoritmos e modelos de 
programação que se adequem às suas características e exigências particulares, entre elas, uso
de recursos limitados, adaptação dinâmica das aplicações, e a necessidade de integração com
outras redes, como a Internet.

Sistemas projetados para os dispositivos que formam as redes de sensores devem lidar apropriadamente
com as restrições e características particulares desses ambientes. 
A arquitetura adotada pelo TinyOS~\cite{tinyos/00} --- um dos sistemas operacionais mais usados
na pesquisa nessa área --- prioriza fortemente o tratamento dessas restrições em 
detrimento da simplicidade oferecida para o desenvolvimento de aplicações. 
A linguagem de programação usada é o nesC~\cite{nesc/03}, uma extensão de C que provê um modelo de programação baseado
em componentes e orietado a eventos.
%que provê baixo consumo de memória, optimizações, e previne condições de corrida.
%^^ Destacar depois em caracteristicas de nesC
Para lidar com as diversas operações de entrada e saída, o TinyOS utiliza um modelo de 
execução em duas fases, evitando bloqueios e, consequentemente, armazenamento de estados. 
A primeira fase da operação é um comando que pede ao hardware a execução de um serviço 
(ex.: sensoreamento). Este comando retorna imediatamente dando continuidade à execução. Quando o
serviço é terminado, o hardware envia uma interrupção, sinalizada como um evento pelo TinyOS. 
Então, o tratador do evento recebe as informações (ex.: valor sensoreado) e trata/processa essas informações conforme programado. 
O problema gerado por essa abordagem é a falta da visão de um fluxo contínuo de execução 
na perspectiva do programador. 

O modelo de concorrência divide o código em dois tipos: assíncrono e síncrono. 
Um código assíncrono pode ser alcançável a partir de pelo menos
um tratador de interrupção. Em função disso, a execução desses trechos do programa pode ser interrompida
a qualquer momento e é necessário tratar possíveis condições de corrida.
Um código síncrono é alcançável somente a partir de tarefas (\textit{tasks}) que são 
procedimentos adiados (postergados). Tarefas executam até terminar (não existe concorrência entre elas), 
por isso as condições de corrida, neste contexto, são evitadas.  
As tarefas são todas escalonadas por um componente do TinyOS que usa uma política padrão de escalonamento 
do tipo \textit{First-in First-out}~\cite{LevisGay/09}.

Com o objetivo de oferecer maior flexibilidade aos desenvolvedores de aplicações, 
a versão mais atual do TinyOS (versão 2.1.x) trouxe novas facilidades.
Uma delas é a possibilidade de substituir o componente de escalonamento de tarefas
para implementar diferentes políticas de escalonamento~\cite{TEP106}.
A outra é a possibilidade de usar o modelo de programação multithreading,
 mais conhecido pelos desenvolvedores de aplicações e que pode
ser usado como alternativa para lidar com as dificuldades da programação orientada a eventos.

Neste trabalho avaliamos essas novas facilidades do TinyOS e propomos extensões que visam oferecer facilidade adicionais
para os desenvolvedores de aplicações.
Inicialmente propusemos novos escalonadores de tarefas, implementando diferentes políticas de escalonamento por
prioridade e avaliamos o modelo de multithreading oferecido, comparando diferentes formas de implementação
de uma aplicação básica e o custo da gerência de threads. Em seguida, tomando como base o modelo multithreading
oferecido, projetamos um mecanismo de gerência cooperativa de tarefas para o TinyOS, visando 
uma solução alternativa entre o modelo de escalonamento de tarefas que executam até terminar 
e evitam condições de corrida, e o modelo de execução alternada entre as tarefas 
que permite maior flexibilidade durante a execução, mas com custo de gerência alto.

O modelo de gerência cooperativa de tarefas é uma solução viável para as redes de sensores sem fios devido simplicidade
do hardware. Como os processadores têm somente um núcleo, e não possuem tecnologia hyperthreading, não é possível 
existir duas unidades de execução rodando em paralelo. Portanto uma gerência cooperativa de tarefas seria uma solução
menos custosa, por eliminar a necessidade de mecânismos de sincronização, e diminuir o número de trocas de contexto.

%!!!Acrescentar organização do resto do texto!!!

%----------------------------------------------------------------------------------------------------
%\section{Objetivos}\label{objetivos}
%Os principais objetivos deste trabalho são:
%\begin{itemize}
%\item aprofundar o conhecimento sobre o modelo de concorrência do TinyOS;
%\item avaliar as novas facilidades introduzidas na versão 2.1.x do TinyOS, 
%incluindo a possibilidade de alterar o componente de escalonamento de tarefas e a implementação de threads;
%\item propor e desenvolver diferentes políticas de escalonamento de tarefas;
%\item implementar um mecanismo de gerência cooperativa de tarefas para o TinyOS baseado no 
%conceito de co-rotinas~\cite{Rossetto/06}.
%\end{itemize}

%----------------------------------------------------------------------------------------------------
\section{Conceitos Básicos}\label{teoria}

\subsection{Rede de Sensores Sem Fio, TinyOS e nesC}
Uma rede de sensores sem fio (RSSF) é um conjunto de dispositivos formando uma rede de comunicação \textit{ad-hoc}. Cada
sensor tem a capacidade de monitorar diversas propriedades físicas, como intensidade luminosa, temperatura, aceleração,
entre outras. Através de troca de mensagens, esses dispositivos podem unir todas essas informações para detectar um evento
importante no local, como um incêndio. Essa conclusão é então encaminhada para um nó com maior capacidade computacional,
conhecido como estação base. Este nó pode decidir uma ação a ser tomada, ou enviar a informação pela internet. Uma RSSF
é usada para monitorar ambientes de difícil acesso, onde uma rede cabeada seria inviável ou custosa.
Alguns exemplos reais do uso de RRSF são: monitoramento da ponte Golden Gate em São Francisco, e dos vulcões Reventador e Tungurahua no
Equador~\cite{LevisGay/09}. 
Além da necessidade de serem sem fio, a outra principal característica dos sensores é o baixo consumo de energia. Para
evitar manutenções da rede, em ambientes de difícil acesso.

Para aumentar o tempo de vida das baterias, o hardware destes dispositivos tende a ter recursos computacionais
limitados. Ao invés de utilizar CPUs, são usados microcontroladores de 8 ou 16 bits, com frequências na ordem de 10
megahertz. Para armazenar o código da aplicação é utilizada uma pequena memória flash, da ordem de 100kB. E para as
variáveis existe uma memória RAM, da ordem de 10kB. Os circuitos de rádio também têm uma capacidade reduzida de
transferência, da ordem de kilobytes por segundos~\cite{LevisGay/09}.
Aliado ao hardware, o software também deve ser voltado para o baixo consumo de energia e de memória.

O TinyOS é o sistema operacional mais usado para auxiliar os programadores a desenvolverem aplicativos de baixo consumo. Junto com a
linguagem de programação nesC, é provido um modelo de programação baseado em componentes e orientado a eventos.
Os componentes são pedaços de código reutilizáveis, onde são definidas claramente suas dependências e os serviços
oferecidos, por meio de interfaces. É através da conexão (\textit{wiring}) de diversos componentes que o sistema é montado.

Já o modelo de programação orientado a eventos permite que o TinyOS rode uma aplicação, com somente uma linha de
execução, sem a necessidade de ações bloqueantes. Todas as operações de entrada e saída são realizadas em duas fases.
Na primeira fase, o comando de E/S sinaliza para o hardware o que deve ser feito, e retorna imediatamente, dando continuidade a
execução. A conclusão da operação é sinalizada através de um evento, que será tratado pela segunda fase da operação de E/S.

O modelo de programação baseada em compontenes está intimamente ligada à programação orientada a eventos: Um componente
oferece a interface, implementando os comandos e as sinalizações dos evento relacionandos, enquanto outro componente
utiliza a esta interface, utilizando os comandos e implementando os tratadores de evento.

Também é implementado o conceito de procedimento postergados, chamados de tarefas, ou \textit{tasks}, no TinyOS. Qualquer
componentes pode postar uma tarefa, que será atendida pelo escalonador, algum tempo depois, de forma síncrona.  Elas são 
executadas de forma não preemptiva entre si, o que ajuda a evitar condições de corrida. Além de serem utilizadas para
sairmos de um contexto assíncrono para um contexto síncrono. 
Por exemplo, um tratador de interrupção deve fazer somente o processamento mínimo, como transferência de dados entre o
\textit{buffer} e a memória. Após isto, deve postar uma tarefa para sinalizar o evento 
de conclusão da operação de E/S. Depois de um curto periodo de tempo, esta terefa será atendida, e sinalizará o evento de 
forma síncrona.

O TinyOS, assim como qualquer outro sistema operacional, também provê um conjunto de abstrações de hardware, como serviços 
de sensoreamento, comunicação e armazenamento.

A aplicação \textit{Blink}, no anexo~\ref{a:Blink}, é utilizada para ilustrar estes conceitos básicos. Nesta aplicação, são utilizados
3 temporizadores, que ligam/desligam os LEDs toda vez que são ativados. Dentre os conceitos explicados acima, temos:
\begin{itemize}
\item Definição das dependências através de interfaces --- uses interface Timer<TMilli> as Timer0;
\item Conexão entre componentes --- components new TimerMilliC() as Timer0; \hfill \\
        BlinkC.Timer0 -> Timer0;
\item Chamada a um comando --- call Time0.startPeriodic(250);
\item Tratador de evento --- event void Timer0.fired()
\item Definição de tarefas --- task void tarefa()
\item Postagem de tarefas --- post tarefa();
\end{itemize}
% ANEXAR

\subsection{Escalonamento de tarefas}
As tarefas, por serem procedimentos adiados, necessitam de algoritmos de escalonamento. Estes algoritmos também não
podem ser preemptivos, devido a natureza das tarefas do TinyOS.
O algoritmo mais simples, e também o padrão do TinyOS, é o \textit{First-Come, First-Served}, onde as tarefas são
atendidas segundo a ordem de chegada. Tem um \textit{overhead} mínimo, e não gera \textit{starvation}. Pode ter um tempo de
resposta alto, se houver uma grande quantidade de tarefas na fila.

Escalonamento utilizando \textit{deadline} é muito usado em sistemas operacionais de tempo real. Neste algoritmo
a próxima tarefa a ser executada é aquela com menor prazo (\textit{deadline}). As diversas variações deste algoritmo utilizam
parâmetros como: 
\begin{itemize}
    \item Tempo de entrada na fila de prontos.
    \item Prazo para começar a tarefa.
    \item Prazo para terminar a tarefa.
    \item Tempo de processamento.
    \item Recursos utilizados.
    \item Prioridade.
    \item Existência de preempção.
\end{itemize}
Porém, o principal parâmetro utilizado pelos algoritmos é a existência ou não de preempção. Caso não exista preempção,
faz mais sentido utilizarmos, no escalonamento, o prazo para começar a tarefa. Caso exista preempção, o prazo para
terminar a tarefa é utilizado~\cite{Stallings/04}.
Um \textit{overhead} bem maior passa a existir, porém o tempo de resposta pode ser aproximadamente estipulado pela
própria tarefa.
% !!! Talvez devesse melhorar esta parte !!!

Em um escalonamento de prioridade fixa, cada tarefa indica, no momento de entrada para fila de prontos, sua importância em relação às
outras tarefas. Nestes algoritmos podemos ter preempção por parcela de tempo, na entrada de outras tarefas, ou não ter preempção. 
No primeiro tipo, pode existir um \textit{overhead} desnecessário quando o \textit{time-slice} da tarefa atual terminou,
porém não existe nenhuma outra com prioridade maior. O segundo tipo resolve este problema: Se existe uma ordem de
tarefas na fila, esta ordem só pode mudar caso uma nova tarefa entre.
Quando não há preempção, a troca de tarefa só ocorre no final da que está executando.
Neste escalonamento também há um \textit{overhead} grande, devido a ordenação das tarefas na fila. Também é introduzido
a possibilidade de \textit{starvation} e um alto tempo de resposta para tarefas de baixa prioridade.

O escalonamento de multi-nível é um caso especial do de prioridade fixa. 
Cada tarefa determina seu nível de prioridade em tempo de compilação. Onde cada nível de prioridade tem uma fila, com 
política \textit{First-in First-out}, e as filas mais importantes devem ser atendidas por completo para que outra sejam
atendidas.

O escalonamento de prioridade dinâmica visa eliminar a possibilidade de \textit{starvation}. Neste caso, a tarefa ainda
indica sua importância no momento de entrada para fila de prontos. Porém, as tarefas que estão esperando para executar
aumentam de prioridade toda vez que não são atendidas. Apesar disto aumentar significativamente o \textit{overhead}, o
\textit{starvation} é eliminado.

\subsection{Multithreading e corotinas}
a

%----------------------------------------------
%!!! Deveria a partir daqui ser uma nova sessão ? !!!
\subsection {Sequência de inicialização do TinyOS}
O principal componente do TinyOS, responsável por inicializar o sistema, é chamado \textit{MainC}. 
Ele inicializa os componentes de hardware e software e o escalonador de tarefas. 

Primeiro é configurado o sistema de memória e escolhido o modo de processamento. 
Com esses pré-requisitos básicos estabelecidos,  o escalonador de tarefas é inicializado 
para permitir que as próximas etapas possam postar tarefas.
O segundo passo é inicializar os demais componentes de hardware, permitindo a operabilidade da plataforma.
Alguns exemplos são configuração de pinos de entrada e saída, calibração do clock e dos LEDs.
Como esta etapa exige códigos específicos para cada tipo de plataforma, o MainC se liga ao componente
\textit{PlataformC} que implementa o tratamento requerido por cada tipo de plataforma.

O terceiro passo trata da inicialização dos componentes de software. 
Além de configurar os aplicativos básicos do sistema, como
os \textit{timer}s, nesta etapa são executados também os procedimentos de inicialização dos componentes 
da aplicação. Para isso, os componentes da aplicação que precisam ser inicializados devem ser amarrados/ligados ao componente 
{\em SoftwareInit}. Assim, durante a etapa de inicialização do sistema, os códigos de inicialização dos componentes da
aplicação são automaticamente chamados.
% !!! Esse paragrafo a cima parece ter muito a palavra inicialização !!!

Por último, quando todas as etapas foram concluídas, o MainC avisa a aplicação que a inicialização terminou, através do
evento \textit{Boot.booted()}. O TinyOS entra no
seu laço principal, no qual o escalonador espera por tarefas e as executa. É importante notar que
durante todo o processo as interrupções do sistema ficam desabilitadas~\cite{TEP107}.


%----------------------------------------------
\subsection{Modelo de concorrência do TinyOS}
O TinyOS define o conceito de {\em tasks} (tarefas) como mecanismo central para
lidar com as questões de concorrência nas aplicações. 
Tarefas têm duas propriedades importantes. Elas não são preemptivas entre si, e são
executadas de forma adiada. Isso significa que ao postar uma tarefa, o fluxo de execução continua,
sem desvio, e ela só será processada mais tarde. 
Na definição básica do TinyOS, as tarefas não recebem parâmetros e não retornam resultados. 

O TinyOS minimiza os problemas clássicos de concorrência garantindo que qualquer possível condição de
corrida gerada a partir de tratadores de interrupção, seja detectada em tempo de compilação. 
Para que isso seja possível, o código em nesC é dividido em dois tipos:
\begin{description}
    \item[Código Assíncrono] Código alcançável a partir de pelo menos um tratador de interrupção.
    \item[Código Síncrono] Código alcançável somente a partir de tarefas.
\end{description}

Eventos e comandos que podem ser sinalizados ou chamados a partir de um tratador de interrupção são códigos assíncronos.
Eles podem interromper a execução de tratadores de eventos, comandos e \textit{tasks}. 
Por isso devem ser marcados como \textit{async} no código fonte. 
Condições de corrida podem ocorrer quando esses trechos de código acessam variáveis compartilhadas.
Para contornar isso, deve-se usar o comando \textit{atomic} ou \textit{power locks}.

O comando \textit{atomic} garante exclusão mútua desabilitando interrupções. Dois fatos
importantes surgem com o seu uso, primeiro a ativação e desativação de interrupções consome ciclos de CPU. Segundo,
longos trechos atômicos podem atrasar outras interrupções, portanto é preciso tomar cuidado ao chamar outros componentes
a partir desses blocos.

Algumas vezes é preciso usar um determinado hardware por um longo tempo, sem compartilhá-lo. 
Como a necessidade de atomicidade não está no processador e sim no hardware, 
pode-se conceder sua exclusividade a somente um usuário (componente) através de
\textit{Power locks}. Para isso, primeiro é feito um pedido através de um comando, depois quando o recurso desejado
estiver disponível, um evento é sinalizado. Assim não há espera ocupada (similar ao mecanismo de semáforos). 
Existe a possibilidade de requisição imediata. 
Nesse caso nenhum evento será sinalizado: se o recurso não estiver locado por outro usuário (componente), ele será
imediatamente cedido, caso contrário, o comando retornará falso. 
~\cite[Cap.11]{LevisGay/09}.

%----------------------------------------------
\subsection{Escalonador padrão de tarefas do TinyOS}\label{escalonadorpadrao}
O componente responsável por gerenciar e escalonar tarefas no TinyOS é o componente {\em TinySchedulerC}.
O escalonador padrão adota uma política {\em First-in First-out} para agendar as tarefas. Ele também
cuida de parte do gerenciamento de energia, colocando a CPU em um estado de baixo consumo quando
não há nada para ser executado.

O escalonador padrão provê as interfaces \textit{Scheduler} e \textit{TaskBasic}.
As tarefas se conectam ao escalonador através da interface \textit{TaskBasic}. 
Ao compilar um programa em nesC, todas tarefas
básicas viram uma interface desse tipo. Porém, para se diferenciarem é criado um parâmetro na interface
\footnote{Para mais informações sobre interfaces parametrizadas ver o livro 
TinyOS Programming\cite[s. 8.3 e 9]{LevisGay/09}.}.

Na versão 2.1.x do TinyOS é possível mudar a política de gerenciamento de tarefas substituindo 
o escalonador padrão. Qualquer novo escalonador tem de
aceitar a interface de tarefa padrão, e garantir a execução de todas as tarefas 
(ausência de {\em starvation})~\cite{TEP106}.

Para alterar o escalonador basta adicionar uma configuração com o nome {\em TinySchedulerC} 
no diretório da aplicação e amarrá-la ao componente responsável pela implementação da aplicação. 
Dentro desta configuração, amarra-se a interface \textit{Scheduler} 
à implementação do escalonador~\cite{TEP106}, como mostra o exemplo abaixo:

\begin{lstlisting}
configuration TinySchedulerC {
    provides interface Scheduler; }
implementation  {
    components SchedulerDeadlineP;
    Scheduler = SchedulerDeadlineP; }
\end{lstlisting}

É preciso também criar a interface para o novo tipo de tarefa, com o comando \textit{postTask} e o evento
\textit{runTask}. Por exemplo:
\begin{lstlisting}
interface TaskDeadline<precision_tag> { 
    async command error_t postTask(uint32_t deadline);
    event void runTask(); }
\end{lstlisting}

Por último, deve-se amarrar a interface da tarefa com a interface do escalonador. Por exemplo:
\begin{lstlisting}
configuration TinySchedulerC {
    provides interface Scheduler;
    provides interface TaskBasic[uint8_t id];
    provides interface TaskDeadline<TMilli>[uint8_t id];
}
implementation  {
    components SchedulerDeadlineP;
    ...
    Scheduler = SchedulerDeadlineP;
    TaskBasic = Sched; 
    TaskDeadline = Sched;
}
\end{lstlisting}


Para que o escalonador funcione corretamente no simulador TOSSIM é preciso adicionar funções que lidam com eventos no
simulador. Essas funções foram retiradas do arquivo
\textit{opt/tinyos-2.1.1/tos/lib/tossim/SimSchedulerBasicP.nc}.
Primeiro é preciso adicionar ao componente \textit{Scheduler} o código abaixo:
\begin{lstlisting}[frame=single]
  bool sim_scheduler_event_pending = FALSE;
  sim_event_t sim_scheduler_event;
  int sim_config_task_latency() {return 100;}
  void sim_scheduler_submit_event() {
    if (sim_scheduler_event_pending == FALSE) {
      sim_scheduler_event.time = sim_time() + sim_config_task_latency();
      sim_queue_insert(&sim_scheduler_event);
      sim_scheduler_event_pending = TRUE;
    }
  }
  void sim_scheduler_event_handle(sim_event_t* e) {
    sim_scheduler_event_pending = FALSE;
    if (call Scheduler.runNextTask()) {
      sim_scheduler_submit_event();
    }
  }
  void sim_scheduler_event_init(sim_event_t* e) {
    e->mote = sim_node();
    e->force = 0;
    e->data = NULL;
    e->handle = sim_scheduler_event_handle;
    e->cleanup = sim_queue_cleanup_none;
  }
\end{lstlisting}

Depois, no comando \textit{Scheduler.init()} deve-se adicionar:
\begin{lstlisting}[frame=single]
  sim_scheduler_event_pending = FALSE;
  sim_scheduler_event_init(&sim_scheduler_event);
\end{lstlisting}
E, por último, no comando \textit{Scheduler.postTask()}, deve-se adicionar:
\begin{lstlisting}[frame=single]
  sim_scheduler_submit_event();
\end{lstlisting}

%----------------------------------------
\subsection{TinyOS Threads} \label{TOSThreads}
\subsubsection{Modelo de threads do TinyOS}
%!!!explicar esse trecho melhor depois!!!
%Os conceitos já utilizados/implementados por threads que ajudarão na criação de uma interface do corotinas são: 
%Chamadas bloqueantes ao sistema, re-aproveitamento dos serviçõs oferecidos, bloco de controle de threads (TCB), e
%a da troca de contexto.

\textit{TOSThreads} permite programação com threads no TinyOS sem violar ou limitar o modelo de concorrência do
sistema. O TinyOS executa em uma única thread --- no de kernel --- enquanto a aplicação executa 
em uma ou mais threads --- nível de usuário.
Em termos de escalonamento, o kernel tem prioridade máxima, ou seja, a aplicação só executa quando o núcleo do sistema
está ocioso. Ele é responsável pelo escalonamento de tarefas e execução das chamadas de sistemas. 

%!!!explicar esse trecho melhor depois!!!
%A interface entre as threads de usuário e de kernel é feito através de chamadas de sistema bloqueantes. Essas
%chamadas são implementadas aproveitando os serviços já disponíveis do TinyOS. 
%São responsáveis por manter o estado do serviço 
%\textit{split-phase} que será usado, bloquear a thread que a invocou e acordar a thread do kernel.

Três tipos de contextos de execução passam a existir: tarefas, interrupções e threads. Tarefas e interrupções podem
interromper threads de aplicação, mas não o contrário. Threads tem preempção entre elas, 
de modo que é necessário o uso de primitivas de sincronização. 
As opções fornecidas são \textit{mutex}, semáforos, barreiras, variáveis de condição, e contador
bloqueante. Esta última foi desenvolvida especialmente para o TinyOS. Seu uso se dá de forma que a thread fica bloqueada
até o contador atingir um número arbitrário, enquanto outras threads podem incrementar ou decrementar esta variável
através de uma interface específica.
%!!!explicar esse trecho melhor depois!!!
%O TinyOS retoma o controle sobre a aplicação de dois modos diferentes. No primeiro, uma aplicação faz uma chamada de
%sistema que posta uma tarefa para processar o serviço. No segundo modo, um manipulador de interrupção posta uma tarefa.
%Porém, neste caso o TinyOS só acorda depois de terminada a execução da interrupção.
O escalonador de threads utiliza uma política \textit{Round-Robin} com um tempo de 5 milisegundos. É ele que oferece
toda a interface para manipulação de threads, como pausar, criar e destruir. 
%!!!explicar esse trecho melhor depois!!!
%É interessante notar que o escalonador não
%existe em um contexto de execução específico, seu contexto depende de quem utilizou sua interface.

As threads podem ser estáticas ou dinâmicas. A diferença está no momento de criação da pilha e do bloco de controle da
thread. Nas threads estáticas a criação é feita em tempo de compilação, enquanto nas threads dinâmicas 
a criação é feita em tempo de execução. O bloco de controle, também chamado de
\textit{Thread Control Block} (TCB), contém informações essenciais da thread, como seu identificador, seu estado de
execução, o valor dos registradores (para troca de contexto), entre outras\cite{TEP134}.
A troca de contexto é feita por códigos específicos para cada plataforma. 

%---------------------------------------------------------------------------------

%!!!Texto não revisado a partir daqui até a section Escalonadores propostos!!!
\subsubsection{Implementação}
A seguir descrevemos detalhes da implementação do \textit{TOSThread}. Mostraremos a organização dos diretório e os
códigos fonte mais importantes.

\paragraph{Organização dos diretórios:}
O diretório raiz do \textit{TOSThread} é \textit{/opt/tinyos-2.1.1/tos/lib/tosthreads/}.
Abaixo descrevo sua estrutura básica de diretórios e as respectivas descrições\footnote{Todos os arquivos serão referenciados a partir do diretório
raiz \textit{/opt/tinyos-2.1.1/tos/lib/tosthreads/}. i.e. \textit{types/thread.h}}:
\begin{description}
\setlength{\itemsep}{0.2pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
    \item[chips:] Código específico de chips.
    \item[interfaces:] Interfaces do sistema.
    \item[lib:] Extensões e subsistemas.
        \begin{description}
        \setlength{\itemsep}{0.2pt}
        \setlength{\parskip}{0pt}
        \setlength{\parsep}{0pt}
            \item[net:] Protocolos de rede (protocolos \textit{multihop}).
            \item[printf:] Imprime pequenas mensagens através da porta serial (para depuração).
            \item[serial:] Comunicação serial.
        \end{description}
    \item[platforms:] Código específico de plataformas.
    \item[sensorboards:] Drivers para placas de sensoreamento.
    \item[system:] Componentes do sistema.
    \item[types:] Tipos de dado do sistema (arquivos header).
\end{description}

\paragraph{Sequência de Boot:}
Na inicialização do \textit{TinyOS} com threads, primeiro há um encapsulamento da thread principal. Depois o curso
original é tomado.
A função \textit{main()} está implementada em \textit{system/RealMainImplP.nc}. A partir dela, o escalonador de threads
é chamado através de um signal.
\begin{lstlisting}
module RealMainImplP {
    provides interface Boot as ThreadSchedulerBoot;}
implementation {
    int main() @C() @spontaneous() {
        atomic signal ThreadSchedulerBoot.booted();}
}
\end{lstlisting}
O escalonador de threads, implementado em \textit{TinyThreadSchedulerP.nc}, encapsula a atual unidade de execução
como a thread do kernel. A partir de então, o curso normal de inicialização é executado. 
\begin{lstlisting}
event void ThreadSchedulerBoot.booted() {
    num_runnable_threads = 0;
    //Pega as informacoes da thread principal, seu ID.
    tos_thread = call ThreadInfo.get[TOSTHREAD_TOS_THREAD_ID]();
    tos_thread->id = TOSTHREAD_TOS_THREAD_ID;
    //Insere a thread principal na fila de threads prontas.
    call ThreadQueue.init(&ready_queue);

    current_thread = tos_thread;
    current_thread->state = TOSTHREAD_STATE_ACTIVE;
    current_thread->init_block = NULL;
    signal TinyOSBoot.booted();
}
\end{lstlisting}
Na fase final do \textit{boot}, é feita a inicialização do hardware, do escalonador de tarefas, dos componentes
específicos da plataforma, e de todos os componentes que se ligaram a \textit{SoftwareInit}. É então sinalizado que o 
\textit{boot} terminou, permitindo que o compontente do usuário execute. Por ultimo, o kernel passa o controle para o
escalonador de tarefas.
\begin{lstlisting}
void TinyOSBoot.booted() {
    atomic {
        //Inicializa hardware
        platform_bootstrap();
        call TaskScheduler.init();
        call PlatformInit.init();
        //Executa tarefas postas pela funcao a cima
        while (call TaskScheduler.runNextTask());
        call SoftwareInit.init();
        //Executa tarefas postas pela funcao a cima
        while (call TaskScheduler.runNextTask());
    }
    __nesc_enable_interrupt();
    //Sinaliza boot para o usuario
    signal Boot.booted();
    call TaskScheduler.taskLoop();
}
\end{lstlisting}
No escalonador de tarefas, quando não houver mais \textit{tasks} para executar, o controle é passado para o escalonador
de threads.
\begin{lstlisting}
command void TaskScheduler.taskLoop() {
    for (;;) {
        uint8_t nextTask;

        atomic {
            while((nextTask = popTask()) == NO_TASK) {
                call ThreadScheduler.suspendCurrentThread();
            }
        }
        signal TaskBasic.runTask[nextTask]();
    }
}
\end{lstlisting}

\paragraph{\textit{types/thread.h}:} 
Este arquivo contém os tipos de dados e constantes excenciais para threads. A seguir estão listados esses dados, e seus
respectivos códigos.
Estados que uma thread pode assumir, como ativo, inativo, pronto e suspenso.
\begin{lstlisting}
enum {
    TOSTHREAD_STATE_INACTIVE = 0,  //This thread is inactive and cannot be run until started
    TOSTHREAD_STATE_ACTIVE = 1,  //This thread is currently running on the cpu
    TOSTHREAD_STATE_READY = 2,  //This thread is not currently running, but is not blocked and has work to do 
    TOSTHREAD_STATE_SUSPENDED = 3,  //This thread has been suspended by a system call (i.e. blocked)
};
\end{lstlisting}
Constantes que controlam a quantidade máxima de threads, e o periodo de preempção.
\label{thread_t}Estrutura da thread que contém dados como identificador, ponteiro para pilha, estado, ponteiro para função,
registradores.
\begin{lstlisting}
struct thread {
volatile struct thread* next_thread;  
    //Pointer to next thread for use in queues when blocked
thread_id_t id;                       
    //id of this thread for use by the thread scheduler
init_block_t* init_block;             
    //Pointer to an initialization block from which this thread was spawned
stack_ptr_t stack_ptr;                
    //Pointer to this threads stack
volatile uint8_t state;               
    //Current state the thread is in
volatile uint8_t mutex_count;         
    //A reference count of the number of mutexes held by this thread
uint8_t joinedOnMe[(TOSTHREAD_MAX_NUM_THREADS - 1) / 8 + 1]; 
    //Bitmask of threads waiting for me to finish
void (*start_ptr)(void*);             
    //Pointer to the start function of this thread
void* start_arg_ptr;                  
    //Pointer to the argument passed as a parameter to the start function of this thread
syscall_t* syscall;                   
    //Pointer to an instance of a system call
thread_regs_t regs;                   
    //Contents of the GPRs stored when doing a context switch
};
\end{lstlisting}
Estrutura para controle de chamadas de sistema. Contém seu identificador, qual thread está executando, 
ponteiro para função que a implementa.
\begin{lstlisting}
struct syscall {
struct syscall* next_call;        
    //Pointer to next system call for use in syscall queues when blocking on them
syscall_id_t id;                  
    //client id of this system call for the particular syscall_queue within which it is being held
thread_t* thread;                 
    //Pointer back to the thread with which this system call is associated
void (*syscall_ptr)(struct syscall*);   
    //Pointer to the the function that actually performs the system call
void* params;                     
    //Pointer to a set of parameters passed to the system call once it is running in task context};
\end{lstlisting}
Também existe uma estrutura chamada \textit{init\_block} usada para threads dinâmicas.
%!!!Não entendi este init_block direito!!!

\paragraph{\textit{interfaces/Thread.nc}:} Contém os comandos de gerênciamento da thread e um evento para executá-la.
\begin{lstlisting}
interface Thread {
    command error_t start(void* arg);
    command error_t stop();
    command error_t pause();
    command error_t resume();
    command error_t sleep(uint32_t milli);
    event void run(void* arg);
    command error_t join();
}  
\end{lstlisting}

\paragraph{\textit{interfaces/ThreadInfo.nc}:} Contém um comando \textit{get()} para receber as informações da thread.
\begin{lstlisting}
interface ThreadInfo {
    async command error_t reset();
    async command thread_t* get();
} 
\end{lstlisting}

\paragraph{\textit{interfaces/ThreadScheduler.nc}:} Contém os comandos para gerênciar todas as threads. Essas funções
servem para pegar informações das threads, inicializá-las e trocar de contexto.
\begin{lstlisting}
interface ThreadScheduler {
    async command uint8_t currentThreadId();
    async command thread_t* currentThreadInfo();
    async command thread_t* threadInfo(thread_id_t id);

    command error_t initThread(thread_id_t id);
    command error_t startThread(thread_id_t id);
    command error_t stopThread(thread_id_t id);

    async command error_t suspendCurrentThread();
    async command error_t interruptCurrentThread();

    async command error_t wakeupThread(thread_id_t id);
    async command error_t joinThread(thread_id_t id);
}
\end{lstlisting}

\paragraph{\textit{system/ThreadInfoP.nc}:}\label{ThreadInfoP} Contém o vetor que representa a pilha, as informações da thread,
como visto em \ref{thread_t} e a função que sinaliza a execução.
\begin{lstlisting}
generic module ThreadInfoP(uint16_t stack_size, uint8_t thread_id) { 
provides {
    interface Init; // Para Inicializar as informacoes
    interface ThreadInfo; // Para exportar as Informacoes da thread
    interface ThreadFunction; // Sinaliza para a thread executar 
}}

implementation {
  uint8_t stack[stack_size];
  thread_t thread_info;

  void run_thread(void* arg) __attribute__((noinline)) {
    signal ThreadFunction.signalThreadRun(arg);
  }
  
  error_t init() {
    thread_info.next_thread = NULL;
    thread_info.id = thread_id;
    thread_info.init_block = NULL;
    thread_info.stack_ptr = (stack_ptr_t)(STACK_TOP(stack, sizeof(stack)));
    thread_info.state = TOSTHREAD_STATE_INACTIVE;
    thread_info.mutex_count = 0;
    thread_info.start_ptr = run_thread;
    thread_info.start_arg_ptr = NULL;
    thread_info.syscall = NULL;
    return SUCCESS;
  }

  ... Comandos de interface ...
}
\end{lstlisting} 

\paragraph{\textit{system/StaticThreadP.nc}:}\label{StaticThreadC}
Tem como principal objetivo servir de interface entre uma thread específica e o escalonador. Por exemplo, se
StaticThreadC recebe um comando de pausa, este é repassado para o escalonador executar. Também termina de inicializar a
thread e sinaliza o evento \textit{Thread.run}.
\begin{lstlisting}
module StaticThreadP.nc { ... }
implementation {

error_t init(uint8_t id, void* arg) {                                   
    error_t r1, r2;                                                       
    thread_t* thread_info = call ThreadInfo.get[id]();                    
    thread_info->start_arg_ptr = arg;                                     
    thread_info->mutex_count = 0;                                         
    thread_info->next_thread = NULL;                                      
    r1 = call ThreadInfo.reset[id]();                                     
    r2 = call ThreadScheduler.initThread(id);                             
    return ecombine(r1, r2);                                              
}  

event void 

event void ThreadFunction.signalThreadRun[uint8_t id](void *arg) {
    signal Thread.run[id](arg);
}

command error_t Thread.start[uint8_t id](void* arg) {
    atomic {
        if( init(id, arg) == SUCCESS ) {
            error_t e = call ThreadScheduler.startThread(id);
            if(e == SUCCESS)
                signal ThreadNotification.justCreated[id]();
            return e;
        }
    }
    return FAIL;

    ... Continuacao da implementacao da interface thread ...
    ... Todos os comandos sao simplesmente passados para o ...
    ... equivalente no ThreadScheduler ...
}

\end{lstlisting}

\paragraph{\textit{system/ThreadC.nc}:}
Esta configuração é a ``interface'' da thread com o usuário e com o escalonador. Primeiramente, é ela que prove a 
interface \textit{interfaces/Thread.nc}, por tanto o programador deve codificar o tratador do evento 
\textit{Thread.run} e amarrá-lo a este componente. Em segundo lugar, conecta entre si todos os componentes 
importantes para o gerenciamento. Os principais são \textit{system/MainC} para inicialização da thread no \textit{boot} do sistema,
 \textit{system/ThreadInfoP.nc} como visto em \ref{ThreadInfoP}, e \textit{system/StaticThreadC.nc} como visto em
\ref{StaticThreadC}. A figura abaixo permite uma melhor visualização. As elipses são interfaces, os retângulos são
componentes e as setas indicam qual interface liga os dois componentes.

\includegraphics[scale=0.5]{images/tos-lib-tosthreads-system-ThreadC.png}

\paragraph{\textit{chips/atm128/chip\_thread.h}:}
Antes de expor as funções do escalonador de threads, é importante expor algumas macros de baixo nível que realizam a
troca de contexto. Para guardar o contexto de hardware da thread, criaram a estrutura \textit{thread\_regs\_t}.
\begin{lstlisting}
typedef struct thread_regs {
    uint8_t status;
    uint8_t r0;
    ...
    uint8_t r31;
} thread_regs_t;
\end{lstlisting}
Existem também algumas macros para salvar e restaurar estes registradores.
\begin{lstlisting}
 #define SAVE_STATUS(t)                              \
    __asm__("in %0,__SREG__ \n\t" : "=r" ((t)->regs.status) : );

//Save General Purpose Registers
#define SAVE_GPR(t)                                      \
    __asm__("mov %0,r0 \n\t" : "=r" ((t)->regs.r0) : );  \
    ...

//Save stack pointer
#define SAVE_STACK_PTR(t)             \
    __asm__("in %A0, __SP_L__\n\t"    \
    "in %B0, __SP_H__\n\t"            \
    :"=r"((t)->stack_ptr) : );

#define SAVE_TCB(t) \
   SAVE_GPR(t);      \
   SAVE_STATUS(t);   \
   SAVE_STACK_PTR(t) 

//Definicao das macros de restauracao
...

#define SWITCH_CONTEXTS(from, to) \
   SAVE_TCB(from);                 \
   RESTORE_TCB(to)
\end{lstlisting}
Por último, são definidas duas macros para preparação da thread.
%!!!Ainda não descobri para que serve isso exatamente!!!
%O endereço de uma função será colocado no topo da pilha da thread. Pra que ?
%O status é salvo quando SP está apontando para a pilha da thread atual e não para a pilha da que está sendo preparada.
\begin{lstlisting}
 #define SWAP_STACK_PTR(OLD, NEW) \
   __asm__("in %A0, __SP_L__\n\t in %B0, __SP_H__":"=r"(OLD):);\
   __asm__("out __SP_H__,%B0\n\t out __SP_L__,%A0"::"r"(NEW))
 
#define PREPARE_THREAD(t, thread_ptr)                      \
{  uint16_t temp;                                        \
   SWAP_STACK_PTR(temp, (t)->stack_ptr);                 \
   __asm__("push %A0\n push %B0"::"r"(&(thread_ptr)));   \
   SWAP_STACK_PTR((t)->stack_ptr, temp);                 \
   SAVE_STATUS(t)                                        \
}
\end{lstlisting}

\paragraph{\textit{system/TinyThreadSchedulerP.nc}:}
Durante a inicialização do sistema muitas inicializações são feitas através da interface \textit{Init} amarrada ao
compontente \textit{MainC}. Isso ocorre com a \textit{system/StaticThreadP.nc}. Como visto acima, durante a execução
desta função, o escalonador é chamado através do comando a seguir.
\begin{lstlisting}
command error_t ThreadScheduler.initThread(uint8_t id) {
    thread_t* t = (call ThreadInfo.get[id]());
    t->state = TOSTHREAD_STATE_INACTIVE;
    t->init_block = current_thread->init_block;
    call BitArrayUtils.clrArray(t->joinedOnMe, sizeof(t->joinedOnMe));
    PREPARE_THREAD(t, threadWrapper);
        //uint16_t temp;                                        \
        //SWAP_STACK_PTR(temp, (t)->stack_ptr);                 \
        //__asm__("push %A0\n push %B0"::"r"(&(threadWrapper)));   \
        //SWAP_STACK_PTR((t)->stack_ptr, temp);                 \
        //SAVE_STATUS(t)   
    return SUCCESS;
}
\end{lstlisting}
É importante notar que na macro \textit{PREPARE\_THREAD()}, o endereço da função \textit{threadWrapper} está sendo
empilhado na pilha da thread. Está função encapsula a chamada para a execução da thread.
\begin{lstlisting}
void threadWrapper() __attribute__((naked, noinline)) {
    thread_t* t;
    atomic t = current_thread;

    __nesc_enable_interrupt();
    (*(t->start_ptr))(t->start_arg_ptr);

    atomic {
        stop(t);
        sleepWhileIdle();
        scheduleNextThread();
        restoreThread();
    }
}
\end{lstlisting}

No laço principal do escalonador de tarefas, quando não há mais nada para executar, a thread atual é suspensa. Com isso
o controle é passado para o escalonador de threads através do comando \textit{suspendCurrentThread()}. Na demostração de
código abaixo, algumas chamadas a funções são substituídas pelo seus corpos, para facilitar o entendimento.
\begin{lstlisting}
async command error_t ThreadScheduler.suspendCurrentThread() {
    atomic {
        if(current_thread->state == TOSTHREAD_STATE_ACTIVE) {
            current_thread->state = TOSTHREAD_STATE_SUSPENDED;
            //suspend(current_thread);
            #ifdef TOSTHREADS_TIMER_OPTIMIZATION
                num_runnable_threads--;
                post alarmTask();
            #endif
            sleepWhileIdle();
            //interrupt(current_thread);
            yielding_thread = current_thread;
            //scheduleNextThread();
            if(tos_thread->state == TOSTHREAD_STATE_READY)
                current_thread = tos_thread;
            else
                current_thread = call ThreadQueue.dequeue(&ready_queue);

            current_thread->state = TOSTHREAD_STATE_ACTIVE;
            //fim scheduleNextThread();

            if(current_thread != yielding_thread) {
                //switchThreads();
                void switchThreads() __attribute__((noinline)) {
                    SWITCH_CONTEXTS(yielding_thread, current_thread);
                 }
                //fim switchThreads();
            }
            //fim interrupt(...)
            //fim suspend(current_thread);
            return SUCCESS;
        }
        return FAIL;
    }
}
\end{lstlisting}
É muito importante notar que a função \textit{switchThreads()} não é \textit{inline}. Isso significa que os valores dos
registradores serão empilhados. Haverá então uma troca de contexto e o registrador SP apontará para a pilha da nova
thread. Por último, a função \textit{switchThreads()} retornará para o endereço que está no topo da nova pilha. Este
novo endereço, como visto acima, aponta para a função \textit{threadWrapper()}. Esta por sua vez, através de uma função
e duas sinalizações executa a thread.

\paragraph{Trocas de Contextos}
acontecem por três motivos diferentes: ocorrência de uma interrupção, termino do tempo de execução da thread, ou chamadas
bloqueantes ao sistema. 
Para implementar o primeiro caso, é inserida a função \textit{postAmble} ao final de todas as rotinas de processamento
de interrupção. Esta função verifica se foi postada uma nova tarefa, e caso positivo, o controle é passado para o
\textit{kernel}. Caso contrário, a thread continua a executar logo após o termino do tratador de interrupção.
Para implementar o segundo caso, é utilizado um temporizador que provoca uma interrupção ao final de cada
\textit{timeslice}. Esta posta uma tarefa, forçando o \textit{kernel} a assumir o controle e escalonar a próxima thread.
%!!!Botar código?!!!

As chamadas de sistema transformam os serviços de duas fases dos TinyOS em chamadas bloqueantes. Para o programador isso
facilita a programação pois torna o fluxo do código continuo. Para permitir isto, essa nova estrutura posta uma tarefa
que executará a primeira fase do serviço (\textit{command}/\textit{call}), suspende a thread e a acorda o
\textit{kernel} para escalonar outra thread. Ao chegar o evento (através de uma tarefa), a \textit{syscall} acorda a thread e lhe repassa o dado.
%!!! Botar código? !!!

%----------------------------------------------------------------------------------------------------
\section{Escalonadores propostos para o TinyOS}\label{escalonadorespropostos}
Nesta seção apresentamos o projeto e as etapas de implementação de novos escalonadores
de tarefas para o TinyOS.
Implementamos três propostas: escalonador EDF (\textit{Earliest Deadline First}), escalonador com prioridades,  
e escalonador multi-nível.

%-----------------------------
\subsection{Escalonador EDF (\textit{Earliest Deadline First})}\label{escalonadoredf}
Este escalonador \footnote{O \cite{TEP106} disponibiliza um protótipo} aceita tarefas com deadline e 
elege aquelas com menor \textit{deadline} para executar. A interface usada para criar
esse tipo de tarefas é \textit{TaskDeadline}. O \textit{deadline} é passado por parâmetro pela função \textit{postTask}.
As tarefas básicas (\textit{TaskBasic}) também são aceitas, como recomendado pelo TEP 106\cite{TEP106}.

Em contraste, o escalonador não segue outra recomendação: não elimina a possibilidade de 
\textit{starvation} pois as tarefas
básicas só são atendidas quando não há nenhuma tarefa com \textit{deadline} esperando para executar. 
A fila de prioridades é implementada da mesma forma que a do escalonador 
padrão\ref{escalonadorpadrao}, a única mudança está na inserção. Para
inserir, a fila é percorrida do começo até o fim, procurando-se o local exato de inserção.
Portanto, o custo de inserir é $\bigcirc(n)$, e o custo de retirar da fila é $\bigcirc(1)$. 
%Uma possível modificação seria utilizar uma \textit{heap}, mudando o custo de inserção  de 
%retirada para $\bigcirc(\logn)$.

%!!!explicar esse trecho melhor depois!!!
%A princípio tive problemas com o componente \textit{Counter32khzC}, 
%pois ele não existe para  a plataforma \textit{micaz}. Para poder compilar o
%escalonador foi preciso retirá-lo. Ele era usado para calcular a hora atual, e somar ao deadline. 
%Sem esse componente, temos um escalonador de prioridades (mínimo). 

%-----------------------------
\subsection{Escalonador com prioridades}\label{escalonadorprioridade}
Desenvolvemos um escalonador onde é possível estabelecer prioridades para as tarefas. 
A prioridade é passada como parâmetro através 
do comando \textit{postTask}. Quanto menor o número passado, maior a preferência da tarefa, sendo 0 a
mais prioritária e 254 a menos prioritária.
As \textit{Tasks} básicas também são aceitas, e são consideradas as tarefas com menor prioridade.

Foram encontrados dois problemas de \textit{starvation}. O primeiro relacionado com as tarefas básicas,
onde elas só seriam atendidas caso não houvesse nenhuma tarefa com prioridade na fila. Para resolver isso, foi definido um
limite máximo de tarefas prioritárias que podem ser atendidas em sequência. Caso esse limite seja excedido, uma tarefa
básica é atendida. O segundo é relacionado às próprias tarefas com prioridade. 
Se entrar constantemente \textit{tasks} com alta
prioridade, é possível que as de baixa prioridade não sejam atendidas. A solução se deu através do envelhecimento de
tarefas. Ou seja, \textit{tasks} que ficam muito tempo na fila, têm sua importância aumentada.

Dois tipos de estrutura de dados foram usadas para a organização das tarefas, uma fila comum e uma \textit{heap}. Com
isso, totalizou-se quatro diferentes versões do escalonador:
\begin{enumerate}
    \item Fila comum sem envelhecimento
    \item Fila comum com envelhecimento
    \item Heap sem envelhecimento
    \item Heap com envelhecimento
\end{enumerate}
A seguir uma tabela com a complexidade de inserção e remoção para cada escalonador:
\begin{center}
    \begin{tabular}{ | l | l | l | l | p{5cm} |}
    \hline
    Escalonador & Inserção & Remoção \\ \hline
    Fila, sem envelhecimento & $\bigcirc(n)$ & $\bigcirc(1)$ \\ \hline 
    Heap, sem envelhecimento & $\bigcirc(\log(n))$ & $\bigcirc(\log(n))$ \\ \hline
    Fila, com envelhecimento & $\bigcirc(n)$ & $\bigcirc(n)$ \\ \hline
    Heap, com envelhecimento & $\bigcirc(\log(n))$ & $\bigcirc(n)$ \\ \hline
    \end{tabular}
\end{center}

%-----------------------------
\subsection{Escalonador multi-nível}
No TinyOS, percebe-se uma divisão clara dos tipos de serviços: 
\begin{description}
    \item[Rádio] Comunicação sem fio entre diferentes nós da rede através de ondas de rádio.
    \item[Sensor] Sensoriamento de diferentes características do ambiente.
    \item[Serial] Comunicação por fio entre um nó e uma estação base (PC).
    \item[Básica] Outros serviços, como por exemplo temporizador.
\end{description}
Por isso, desenvolvemos um escalonador que divide as tarefas de acordo com os tipos definidos acima.
Cada tipo de tarefa tem sua própria fila com política \textit{First-in First-out}, e as filas mais importantes devem ser
atendidas por completo para que as outras sejam antendidas.

%!!!detalhar esse trecho melhor depois!!!
%Definiu-se que a ordem de prioridade seria serial, rádio, sensor e por último básica.

%---------------------------------------------------------------------------------------------------
%!!!Texto desta seção não está revisado!!!
\section{Implementação de co-rotinas para o TinyOS}
O modelo que decidimos implementas foi um descrito por Ana Moura em sua tese de doutorado\cite[s. 6.2]{Moura/04}.
Neste modelo existe uma co-rotina principal que é responsável por escalonar as outras co-rotinas.

Nossa implementação utilizou como base a extensão \textit{TOSThreads}, vista na seção \ref{TOSThreads}. O primeiro passo
foi criar uma cópia do diretório desta extensão e um novo \textit{target} referente a este diretório para o \textit{make} do TinyOS.

Na implementação do \textit{TOSThreads} existem dois casos em que ocorre preempção: termino do \textit{timeslice} e
acontecimento de uma interrupção de hardware. Portanto foi preciso modificar esses dois casos.
A primeira alteração foi retirar o limite de tempo de execução de cada thread. Para isso o temporizador responsável por
essa contagem foi desabilitado.
A segunda alteração foi criar um novo tipo de interrupção, que chamamos de interrupção curta. Originalmente, no
\textit{TOSThreads}, quando o tratador de interrupção postava uma tarefa, o kernel assumia o controle, executava a
tarefa e escalonava a próxima thread da fila. Na nossa implementação, após o kernel executar a tarefa, a thread que foi
originalmente interrompida volta a executar. Para isso, foi criado um novo comando no escalonador de threads:
\textit{brieflyInterruptCurrentThread()}
\begin{lstlisting}
async command error_t ThreadScheduler.brieflyInterruptCurrentThread() {
    atomic {
        if(current_thread->state == TOSTHREAD_STATE_ACTIVE) {
            briefly_interrupted_thread = current_thread;
            briefly_interrupted_thread->state =
                TOSTHREAD_STATE_BRIEFLYINTERRUPTED;
            interrupt(current_thread);
            return SUCCESS;
        }
        return FAIL;
    }
}

/* schedule_next_thread()
 * This routine does the job of deciding which thread should run next.
 * Should be complete as is.  Add functionality to getNextThreadId() 
 * if you need to change the actual scheduling policy.
 */
    void scheduleNextThread() {
        if(tos_thread->state == TOSTHREAD_STATE_READY)
            current_thread = tos_thread;
        else if (briefly_interrupted_thread != NULL)
        {
            current_thread = briefly_interrupted_thread;
            briefly_interrupted_thread = NULL;
        }
        else
            current_thread = call ThreadQueue.dequeue(&ready_queue);

        current_thread->state = TOSTHREAD_STATE_ACTIVE;
    }

\end{lstlisting}

Uma vez excluída a preempção, o proxímo passo foi modificar a interface da thread para permitir passagem de controle ao
escalonador. Para isso, foi criado o comando \textit{yield()}. É importante notar que este comando pode ser chamado em 
qualquer ponto do programa, porém só deve ser chamado dentro da thread ao qual o comando se refere.
\begin{lstlisting}
//Arquivo: interfaces/Thread.nc
interface Thread {
    ...
    command error_t yield();
    ...
}

//Arquivo: system/StaticThreadP.nc
module StaticThreadP {
    ...
    command error_t Thread.yield[uint8_t id]() { 
        return call ThreadScheduler.interruptCurrentThread(); 
    } 
    ...
}
\end{lstlisting}

%!!! Que tal adicionar um apendice mostrando o passo-a-passo da implementação de co-rotinas? !!!


%----------------------------------------------------------------------------------------------------
\section{Experimentos realizados}\label{resultados}
Nesta seção apresentamos os experimentos realizados e os resultados obtidos.

%---------------------------------
\subsection{Experimentos com o escalonador de tarefas padrão}
Antes de começar a desenvolver outros escalonadores de tarefas, foi feito um experimento com o escalonador 
padrão que utiliza a política \textit{First in, First Out}.
Para medir a complexidade na prática, foi desenvolvida uma aplicação de teste. Nela cada tarefa executa um loop de 65000
iterações, fazendo uma simples multiplicação em cada iteração. O número de tarefas variou entre 20, 50 e 100.
Na tabela a seguir pode-se ver o tempo de execução em microsegundos:
\begin{center}
    \begin{tabular}{ | l | l | l | l | p{5cm} |}
    \hline
    Escalonador              & 20 Tarefas & 50 Tarefas & 100 Tarefas \\ \hline
    Escalonador Padrão       & 1366 & 1849 & 2652 \\ \hline
    \end{tabular}
\end{center}

%---------------------------------
\subsection{Experimentos com o escalonador com prioridades}
Para avaliar o desempenho com o escalonador com prioridades foi desenvolvida a mesma aplicação de teste,
onde cada tarefa executa um loop de 65000 iterações, fazendo uma simples multiplicação em cada iteração. 
O número de tarefas variou entre 20, 50 e 100.
Na tabela a seguir pode-se ver o tempo de execução em microsegundos:
\begin{center}
    \begin{tabular}{ | l | l | l | l | p{5cm} |}
    \hline
    Escalonador              & 20 Tarefas & 50 Tarefas & 100 Tarefas \\ \hline
    Escalonador Padrão       & 1366 & 1849 & 2652 \\ \hline 
    Fila, sem envelhecimento & 1733 & 4660 & 13721 \\ \hline 
    Heap, sem envelhecimento & 2603 & 4308 & 7486 \\ \hline
    Fila, com envelhecimento & 2278 & 7887 & 26066 \\ \hline
    Heap, com envelhecimento & 2665 & 4510 & 7887 \\ \hline
    \end{tabular}
\end{center}

Podemos perceber que, para um número pequeno de tarefas, a fila é mais eficiente que a heap. Isso acontece pois
não é compensado o \textit{overhead} do algoritmo da heap.

%----------------------------------------------------------------------------------------------------
\section{Conclusões}\label{conclusoes}
As redes de sensores sem fio podem ser aplicadas em diversas áreas, por exemplo, monitoramento de oscilações 
e movimentos de pontes, observação de vulcões ativos, previsão de incêndio em florestas, entre outras. 
Muitas dessas aplicações podem atingir alta complexidade, exigindo a construção de algoritmos robustos, 
como roteamento de pacotes diferenciado.
Os escalonadores desenvolvidos neste trabalho poderão ajudar os desenvolvedores dessas aplicações complexas,
oferecendo maior flexibilidade no projeto das soluções, como, por exemplo, 
a possibilidade de priorizar certas atividades da aplicação (comunicação via rádio ou serial, sensoriamento, etc.).
Porém é preciso analisar se o ganho em flexibilidade, oferecido pelo escalonador, irá compensar o
\textit{overhead} gerado.
Pretendemos realizar ainda outros experimentos com os escalonadores desenvolvidos, considerando diferentes
tipos de aplicações. 

Sem um fluxo contínuo de execução, sobre a perspectiva do programador, as aplicações grandes ficam difíceis de
implementar e entender. O modelo de \textit{threads} oferecido no 
TinyOS 2.1.X\cite{TEP134} facilita este problema. Entretanto, por ser um modelo preemptivo, o custo de
gerência das threads pode implicar em queda de desempenho das aplicações. 
Com a implementação de um mecanismo de cooperação baseado em co-rotinas pretendemos
oferecer uma alternativa a mais para o programador.

%--------------------------------------------------------------------------------------
\section{Anexos}
\appendix
\section{Blink}\label{a:Blink}
\subsection{BlinkC.nc:}
\lstinputlisting{srcs/BlinkC.nc}

\subsection{BlinkAppC.nc:}
\lstinputlisting{srcs/BlinkAppC.nc}

\section{Aplicação de Teste do Escalonador com Prioridades}
\subsection{aplicacaoTesteC.nc:}
\lstinputlisting{srcs/aplicacaoTesteC.nc}

\subsection{aplicacaoTesteAppC.nc:}
\lstinputlisting{srcs/aplicacaoTesteAppC.nc}


%\subsection{Atividades extras}
%Outras atividades realizadas pelo aluno foram:
%\begin{itemize}
%    \item Participação no evento SBAC-PAD 2010 -- 
%{\em 22nd International Symposium on Computer Architecture and High Performance Computing}.
%    \item Participação no minicurso 
%{\em Redes de sensores sem fio sob a perspectiva do EPOS}~\cite{HoellerFrohlich/10}, 
%apresentado no SBAC-PAD 2010.    
%    \item Participação em seminário do grupo de Redes de Computadores e Sistemas Distribuídos (RCSD)
%do Programa de Pós-Graduação em Informática (PPGI).
%\end{itemize}

%\subsection{Avaliação do Bolsista}
%A iniciação científica está sendo uma ótima oportunidade para etender como funciona uma pesquisa. Por meio desse trabalho pude conhecer as redes de sensores sem fio, e um sistema operacional diferente dos convêncionais. É muito prazeroso poder, ao mesmo tempo, estudar e desenvolver novidades. Foi interessante perceber que na prática temos de tomar cuidado com questões que às vezes na teoria são deixadas de lado. Por exemplo, o caso do \textit{overhead} no algoritmo de \textit{Heap} dos escalonadores. 
%
%Este trabalho ajudou na minha decisão de seguir carreira acadêmica. Ainda estou tendo a oportunidade de pesquisar em uma área pouco explorada no meu deparatamento.

%----------------------------------------------------------------------------------------------------
\bibliographystyle{unsrt}
\bibliography{ic}
\end{document}
